package main

import (
	"fmt"
	"strings"

	"github.com/yimi-go/version"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
	gencode "google.golang.org/genproto/googleapis/rpc/code"
	"google.golang.org/grpc/codes"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/pluginpb"

	"github.com/yimi-go/errors"
)

const (
	fmtPackage      = protogen.GoImportPath("fmt")
	errorsPackage   = protogen.GoImportPath("github.com/yimi-go/errors")
	genCodePackage  = protogen.GoImportPath("google.golang.org/genproto/googleapis/rpc/code")
	rpcCodesPackage = protogen.GoImportPath("google.golang.org/grpc/codes")
)

var enCases = cases.Title(language.AmericanEnglish, cases.NoLower)

func genFiles(plugin *protogen.Plugin) error {
	plugin.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)
	for _, file := range plugin.Files {
		if !file.Generate {
			continue
		}
		if len(file.Enums) == 0 {
			continue
		}
		generateFile(plugin, file)
	}
	return nil
}

func generateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	filename := file.GeneratedFilenamePrefix + "_errors.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	generateFileHead(gen, file, g, fmtPackage, errorsPackage, genCodePackage, rpcCodesPackage)
	generateFileContent(file, g)
	return g
}

func generateFileHead(
	gen *protogen.Plugin,
	file *protogen.File,
	g *protogen.GeneratedFile,
	imports ...protogen.GoImportPath,
) {
	g.P("// Code generated by protoc-gen-yimi-errors. DO NOT EDIT.")
	g.P("// versions:")
	g.P("// \tprotoc-gen-yimi-errors ", version.GitVersion)
	protocVersion := "(unknown)"
	if v := gen.Request.GetCompilerVersion(); v != nil {
		protocVersion = fmt.Sprintf("v%v.%v.%v", v.GetMajor(), v.GetMinor(), v.GetPatch())
		if s := v.GetSuffix(); s != "" {
			protocVersion += "-" + s
		}
	}
	g.P("// \tprotoc                 ", protocVersion)
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	for _, path := range imports {
		g.Import(path)
	}
	g.P()
	g.P("// This is a compile-time assertion to ensure that this generated file")
	g.P("// is compatible with the errors package it is being compiled against.")
	g.P("const _ = ", errorsPackage.Ident("SupportPackageIsVersion1"))
	g.P()
}

func generateFileContent(file *protogen.File, g *protogen.GeneratedFile) {
	index := 0
	for _, enum := range file.Enums {
		if !isEnumErrorDefine(enum) {
			continue
		}
		genErrorsReason(g, enum)
		index++
	}
	// If all enums do not contain 'errors.code', the current file is skipped
	if index == 0 {
		g.Skip()
	}
}

func isEnumErrorDefine(enum *protogen.Enum) bool {
	errorDefine := proto.GetExtension(enum.Desc.Options(), errors.E_ErrorDefine)
	if asBool, ok := errorDefine.(bool); ok {
		return asBool
	}
	return false
}

func genErrorsReason(g *protogen.GeneratedFile, enum *protogen.Enum) {
	defaultCode := enumDefaultCode(enum)
	for _, v := range enum.Values {
		pbCode := enumValueCode(defaultCode, v)
		if pbCode == gencode.Code_OK {
			continue
		}
		errName := case2Camel(string(v.Desc.Name()))
		//reason := fmt.Sprintf("%s_%s", enum.Desc.Name(), v.Desc.Name())
		reasonName := v.GoIdent.GoName
		pIsErr := genIsErr(g, errName, reasonName, pbCode)
		g.P(pIsErr)
		g.P()
		pErr := genNewErr(g, errName, reasonName, pbCode)
		g.P(pErr)
		g.P()
	}
}

func genNewErr(g *protogen.GeneratedFile, errName, reasonName string, pbCode gencode.Code) string {
	apiCode := codes.Code(pbCode)
	p := fmt.Sprintf(`
func Error%s(format string, args ...interface{}) *errors.Error {
	return errors.New(%s, %s.String(), %s(format, args...))
}
`,
		errName,
		g.QualifiedGoIdent(rpcCodesPackage.Ident(apiCode.String())),
		reasonName,
		g.QualifiedGoIdent(fmtPackage.Ident("Sprintf")))
	return strings.TrimSpace(p)
}

func genIsErr(g *protogen.GeneratedFile, errName, reasonName string, pbCode gencode.Code) string {
	p := fmt.Sprintf(`
func Is%s(err error) bool {
	if err == nil {
		return false
	}
	e := %s(err)
	return e.Reason == %s.String() && e.Code == %s
}
`,
		errName,
		g.QualifiedGoIdent(errorsPackage.Ident("FromError")),
		reasonName,
		g.QualifiedGoIdent(genCodePackage.Ident(fmt.Sprintf("Code_%s", pbCode))),
	)
	return strings.TrimSpace(p)
}

func enumValueCode(defaultCode gencode.Code, v *protogen.EnumValue) gencode.Code {
	if !proto.HasExtension(v.Desc.Options(), errors.E_Code) {
		return defaultCode
	}
	eCode := proto.GetExtension(v.Desc.Options(), errors.E_Code)
	if asCode, ok := eCode.(gencode.Code); ok {
		return asCode
	}
	return defaultCode
}

func enumDefaultCode(enum *protogen.Enum) gencode.Code {
	eDefaultCode := proto.GetExtension(enum.Desc.Options(), errors.E_DefaultCode)
	if asCode, ok := eDefaultCode.(gencode.Code); ok {
		return asCode
	}
	return gencode.Code_UNKNOWN
}

func case2Camel(name string) string {
	if !strings.Contains(name, "_") {
		upperName := strings.ToUpper(name)
		if upperName == name {
			name = strings.ToLower(name)
		}
		return enCases.String(name)
	}
	name = strings.ToLower(name)
	name = strings.Replace(name, "_", " ", -1)
	name = enCases.String(name)
	return strings.Replace(name, " ", "", -1)
}
